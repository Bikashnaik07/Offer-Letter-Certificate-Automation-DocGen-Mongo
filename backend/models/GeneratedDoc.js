const mongoose = require('mongoose');

const generatedDocSchema = new mongoose.Schema({
    documentId: {
        type: String,
        required: true,
        unique: true,
        // Auto-generate document ID with format: DOC-YYYYMMDD-XXXXX
        default: function() {
            const date = new Date();
            const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
            const random = Math.floor(Math.random() * 99999).toString().padStart(5, '0');
            return `DOC-${dateStr}-${random}`;
        }
    },
    templateId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Template',
        required: [true, 'Template ID is required']
    },
    templateName: {
        type: String,
        required: true
    },
    templateType: {
        type: String,
        required: true
    },
    recipientData: {
        type: mongoose.Schema.Types.Mixed,
        required: [true, 'Recipient data is required']
    },
    generatedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: [true, 'Generated by user is required']
    },
    generationType: {
        type: String,
        enum: ['single', 'bulk'],
        required: true
    },
    batchId: {
        type: String,
        // For bulk generation, all documents in same batch share this ID
        index: true
    },
    outputFormat: {
        type: String,
        enum: ['pdf', 'docx'],
        required: true
    },
    filePath: {
        type: String,
        required: true
    },
    fileName: {
        type: String,
        required: true
    },
    fileSize: {
        type: Number,
        // File size in bytes
    },
    status: {
        type: String,
        enum: ['generating', 'completed', 'failed', 'sent'],
        default: 'generating'
    },
    downloadCount: {
        type: Number,
        default: 0
    },
    lastDownloadAt: {
        type: Date
    },
    emailSent: {
        type: Boolean,
        default: false
    },
    emailSentAt: {
        type: Date
    },
    emailRecipient: {
        type: String,
        trim: true,
        lowercase: true
    },
    metadata: {
        // Additional metadata for the document
        generationTime: Number, // Time taken to generate in milliseconds
        ipAddress: String,
        userAgent: String,
        errorMessage: String // In case of failed generation
    },
    expiresAt: {
        type: Date,
        // Auto-delete documents after specified time (default 30 days)
        default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        index: { expireAfterSeconds: 0 }
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Indexes for better query performance
generatedDocSchema.index({ templateId: 1 });
generatedDocSchema.index({ generatedBy: 1 });
generatedDocSchema.index({ createdAt: -1 });
generatedDocSchema.index({ status: 1 });
generatedDocSchema.index({ batchId: 1 });

// Virtual for document summary
generatedDocSchema.virtual('summary').get(function() {
    return {
        id: this._id,
        documentId: this.documentId,
        templateName: this.templateName,
        templateType: this.templateType,
        recipientName: this.recipientData.name || 'Unknown',
        generationType: this.generationType,
        outputFormat: this.outputFormat,
        status: this.status,
        downloadCount: this.downloadCount,
        emailSent: this.emailSent,
        createdAt: this.createdAt
    };
});

// Virtual for file URL
generatedDocSchema.virtual('fileUrl').get(function() {
    if (this.filePath) {
        return `/generated/${this.outputFormat}/${this.fileName}`;
    }
    return null;
});

// Pre-save middleware to set template info
generatedDocSchema.pre('save', async function(next) {
    if (this.isNew && this.templateId && !this.templateName) {
        try {
            const Template = mongoose.model('Template');
            const template = await Template.findById(this.templateId);
            if (template) {
                this.templateName = template.name;
                this.templateType = template.type;
            }
        } catch (error) {
            console.error('Error setting template info:', error);
        }
    }
    next();
});

// Instance method to increment download count
generatedDocSchema.methods.recordDownload = async function() {
    this.downloadCount += 1;
    this.lastDownloadAt = new Date();
    return this.save({ validateBeforeSave: false });
};

// Instance method to mark email as sent
generatedDocSchema.methods.markEmailSent = async function(recipient) {
    this.emailSent = true;
    this.emailSentAt = new Date();
    this.emailRecipient = recipient;
    this.status = 'sent';
    return this.save({ validateBeforeSave: false });
};

// Instance method to mark as failed
generatedDocSchema.methods.markAsFailed = async function(errorMessage) {
    this.status = 'failed';
    this.metadata = {
        ...this.metadata,
        errorMessage
    };
    return this.save({ validateBeforeSave: false });
};

// Instance method to mark as completed
generatedDocSchema.methods.markAsCompleted = async function(filePath, fileName, fileSize) {
    this.status = 'completed';
    this.filePath = filePath;
    this.fileName = fileName;
    this.fileSize = fileSize;
    return this.save({ validateBeforeSave: false });
};

// Static method to get documents by user
generatedDocSchema.statics.findByUser = function(userId, options = {}) {
    const {
        templateType,
        status,
        generationType,
        page = 1,
        limit = 10,
        sortBy = 'createdAt',
        sortOrder = -1
    } = options;
    
    const query = { generatedBy: userId };
    
    if (templateType) query.templateType = templateType;
    if (status) query.status = status;
    if (generationType) query.generationType = generationType;
    
    return this.find(query)
        .populate('templateId', 'name type')
        .populate('generatedBy', 'name email')
        .sort({ [sortBy]: sortOrder })
        .skip((page - 1) * limit)
        .limit(limit);
};

// Static method to get documents by batch
generatedDocSchema.statics.findByBatch = function(batchId) {
    return this.find({ batchId })
        .populate('templateId', 'name type')
        .populate('generatedBy', 'name email')
        .sort({ createdAt: 1 });
};

// Static method to get audit trail
generatedDocSchema.statics.getAuditTrail = function(options = {}) {
    const {
        userId,
        templateId,
        templateType,
        status,
        dateFrom,
        dateTo,
        page = 1,
        limit = 20
    } = options;
    
    const query = {};
    
    if (userId) query.generatedBy = userId;
    if (templateId) query.templateId = templateId;
    if (templateType) query.templateType = templateType;
    if (status) query.status = status;
    
    if (dateFrom || dateTo) {
        query.createdAt = {};
        if (dateFrom) query.createdAt.$gte = new Date(dateFrom);
        if (dateTo) query.createdAt.$lte = new Date(dateTo);
    }
    
    return this.find(query)
        .populate('templateId', 'name type')
        .populate('generatedBy', 'name email role')
        .sort({ createdAt: -1 })
        .skip((page - 1) * limit)
        .limit(limit);
};

// Static method to get generation statistics
generatedDocSchema.statics.getStatistics = async function(options = {}) {
    const { userId, dateFrom, dateTo } = options;
    
    const matchStage = {};
    if (userId) matchStage.generatedBy = mongoose.Types.ObjectId(userId);
    if (dateFrom || dateTo) {
        matchStage.createdAt = {};
        if (dateFrom) matchStage.createdAt.$gte = new Date(dateFrom);
        if (dateTo) matchStage.createdAt.$lte = new Date(dateTo);
    }
    
    const pipeline = [
        { $match: matchStage },
        {
            $group: {
                _id: null,
                totalDocuments: { $sum: 1 },
                completedDocuments: {
                    $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] }
                },
                failedDocuments: {
                    $sum: { $cond: [{ $eq: ['$status', 'failed'] }, 1, 0] }
                },
                totalDownloads: { $sum: '$downloadCount' },
                emailsSent: {
                    $sum: { $cond: ['$emailSent', 1, 0] }
                }
            }
        }
    ];
    
    // Get statistics by template type
    const typeStats = await this.aggregate([
        { $match: matchStage },
        {
            $group: {
                _id: '$templateType',
                count: { $sum: 1 },
                downloads: { $sum: '$downloadCount' }
            }
        },
        { $sort: { count: -1 } }
    ]);
    
    // Get daily generation count for the last 30 days
    const dailyStats = await this.aggregate([
        {
            $match: {
                ...matchStage,
                createdAt: { 
                    $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) 
                }
            }
        },
        {
            $group: {
                _id: {
                    $dateToString: { format: '%Y-%m-%d', date: '$createdAt' }
                },
                count: { $sum: 1 }
            }
        },
        { $sort: { '_id': 1 } }
    ]);
    
    const [overallStats] = await this.aggregate(pipeline);
    
    return {
        overall: overallStats || {
            totalDocuments: 0,
            completedDocuments: 0,
            failedDocuments: 0,
            totalDownloads: 0,
            emailsSent: 0
        },
        byType: typeStats,
        daily: dailyStats
    };
};

// Static method to cleanup old documents
generatedDocSchema.statics.cleanup = async function(daysOld = 30) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);
    
    const result = await this.deleteMany({
        createdAt: { $lt: cutoffDate },
        status: { $in: ['completed', 'failed'] },
        downloadCount: 0 // Only delete documents that haven't been downloaded
    });
    
    return result.deletedCount;
};

module.exports = mongoose.model('GeneratedDoc', generatedDocSchema);
